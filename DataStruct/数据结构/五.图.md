[TOC]

# 五.图

## 一.图的定义和术语

### I.定义

一般规定，V(**vertex**)是**顶点**的有穷非空集合，E(**Edge**)是**边**的有穷集合。

则**图**(**Graph**)=(V,E)，即**图**是==顶点==和==边==的集合。

边存在方向性的图叫做**有向图**，否则则是**无向图**，其中**有向图**的弧形边称作**弧**。

==**完全图**==:任意两点之间都有一边相连。

==**网**==:边或弧带权的图。

以<u>n logn与e</u>的大小比较来定义**稀疏图**和**稠密图**。

![QQ截图20240423192042](C:\Users\Administrator\Desktop\虚动智能\数据结构\pic\QQ截图20240423192042.png)

### II.术语

顶点的**度**:与该顶点相关联的边的数目，记作TD(v)

![QQ截图20240423192307](C:\Users\Administrator\Desktop\虚动智能\数据结构\pic\QQ截图20240423192307.png)

**路径**：接续的边构成的顶点序列。

**路径的长**：路径上边或弧的数目/权值的和。

**回路**(**环**)：起点和终点相同的路径。

**简单路径**：除了起点和终点可以相同之外其他顶点均不相同的路径。

![QQ截图20240423193541](C:\Users\Administrator\Desktop\虚动智能\数据结构\pic\QQ截图20240423193541.png)

**连通分量**：无向图G的**极大连通子图**称为G的**连通分量**。

**强连通分量**：有向图的**连通分量**。

**极小连通子图**：删除任意一条路径，子图都不再连通。

![QQ截图20240423194420](C:\Users\Administrator\Desktop\虚动智能\数据结构\pic\QQ截图20240423194420.png)

## 二.图的存储结构

图没有顺序存储结构！

但可以通过**二维数组**来表示图的顶点之间的关系。

图的**链式存储结构**有**邻接表**、**邻接多重表**和**十字链表**。

### I.邻接矩阵表示法(数组表示法)

#### 1.无向图的表示

定义邻接矩阵**A.arcs[i] [j]**，两定点之间若相邻，则对应i和j的位置为1，否则为0。

无向图的邻接矩阵是**对称**的。

顶点i的**度**=第i行(列)中1的个数。

#### 2.有向图的表示

对于任意一个顶点，第i行元素之和为该顶点的**出度**。

同理，第i列元素之和为该顶点的**入度**。

若有向图为网，则若存在某一边，则在矩阵的对应位置存放该边的**权值**，否则则存储==∞==。

#### 3.代码实现

```c++
#define MVNum 1000
#define MaxInt 32767
typedef char VerType;
typedef int ArcType;
typedef struct{
    VerType vexs[MVNum]; //顶点表
    ArcType arcs[MVNum][MVNum]; //邻接矩阵
    int vernum,arcnum;
}AMGraph;
```

##### a.无向网

```c++
int LocateVew(AMGraph &G,VerType u){
    int i;
    for(i=0;i<G.vernum;i++)if(G.vexs[i]==u)return i;
    return -1;
}

Status createUDN(AMGraph &G){
     cin>>G.vernum>>G.arcnum;
    for(int i=0;i<G.vernum;i++)cin>>G.vexs[i];
    for(int i=0;i<G.vernum;i++)
        for(int j=0;j<G.vernum;j++)
            G.arcs[i][j]=MaxInt;
    for(k=0;k<G.arcnum;k++){
        cin>>v1>>v2>>weight;
        i=LocateVex(G,v1);
        j=LocateVex(G,v2);
        G.arcs[i][j]=weight;
        G.arcs[j][i]=G.arcs[i][j];
    }
    return OK;
}
```

##### b.无向图

```c++
int LocateVew(AMGraph &G,VerType u){
    int i;
    for(i=0;i<G.vernum;i++)if(G.vexs[i]==u)return i;
    return -1;
}

Status createUDN(AMGraph &G){
     cin>>G.vernum>>G.arcnum;
    for(int i=0;i<G.vernum;i++)cin>>G.vexs[i];
    for(int i=0;i<G.vernum;i++)
        for(int j=0;j<G.vernum;j++)
            G.arcs[i][j]=0;
    for(k=0;k<G.arcnum;k++){
        cin>>v1>>v2>>weight;
        i=LocateVex(G,v1);
        j=LocateVex(G,v2);
        G.arcs[i][j]=1;
        G.arcs[j][i]=G.arcs[i][j];
    }
    return OK;
}
```

##### c.有向图

```c++
int LocateVew(AMGraph &G,VerType u){
    int i;
    for(i=0;i<G.vernum;i++)if(G.vexs[i]==u)return i;
    return -1;
}

Status createUDN(AMGraph &G){
     cin>>G.vernum>>G.arcnum;
    for(int i=0;i<G.vernum;i++)cin>>G.vexs[i];
    for(int i=0;i<G.vernum;i++)
        for(int j=0;j<G.vernum;j++)
            G.arcs[i][j]=0;
    for(k=0;k<G.arcnum;k++){
        cin>>v1>>v2>>weight;
        i=LocateVex(G,v1);
        j=LocateVex(G,v2);
        G.arcs[i][j]=1;
    }
    return OK;
}
```

### II.邻接表表示法

用单链表存储每个顶点的关联顶点，以此来存储边的关系。

顶点v~i~的出度为第i个单链表中结点的个数，入度则需要遍历所有顶点，统计指针指向v~i~的结点的个数。

```c++
typedef struct EdgeNode{ //边表结点
    int vertex; //边所指向的终止顶点
    int weight; //该条边的权值
    struct EdgeNode *next; //指向next的指针
}EdgeNode;
typedef struct VertexNode{ //顶点表结点
    int in; //该顶点的入度
    int data; //该顶点的data值
    EdgeNode *firstedge; //指向EdgeNode的头指针
}VertexNode,VerList[MAXVEX];
typedef struct{ 
    VerList VerList;
    int vernum,arcnum; //记录顶点个数和边的个数
}graphList,*GraphList;
```

建立邻接表:

```c++
Status CreateUDG(GraphList G){
    cin>>G->vernum>>G->arcnum;
    for(int i=0;i<G.vernum;i++){
        cin>>G->VerList[i].data;
        G->VerList[i].firstedge=NULL;
    }
    int i,j;
    for(int k=0;k<G->arcnum;k++){
        cin>>v1>>v2;
        i=LocateVex(G,v1);
        j=LocateVex(G,v2);
        p1=new EdgeNode;
        p1.vertex=j;
        p1.next=G->VerList[i].firstarc;
        G->VerList[i].firstarc=p1;
        /*
        p2=new EdgeNode;
        p1.vertex=i;
        p1->next=G->VerList[j].firstarc;
        G->VerList[j].firstarc=p2;
        无向网的对称需求，若为有向网则不需要这一步
        */
    }
    return OK;
}
```

### III.十字链表(有向图)

![image-20240423213456770](C:\Users\Administrator\Desktop\虚动智能\数据结构\pic\image-20240423213456770.png)

如图，顶点结点存储出弧的头指针和出弧的头指针。

弧结点存储关联的两个结点并存储next的指针。

### IV.邻接多重表(无向图)

## 三.图的遍历

遍历方式分为**广度优先遍历**(BFS)和**深度优先遍历**(DFS)。

### I.深度优先遍历(DFS)

邻接矩阵表示无向图**深度优先递归算法**实现：

```c++
int visited[MVNum];
void DFS(Graphmat G,int v){
    int j;
    visited[v]=1;
    cout<<G.vers[v];//输出i所代表的顶点本身
    for(j=0;j<G.vernum;j++) //遍历所有第i行的元素，以达到遍历效果
        if(G.arcs[v][j]==1&&!visited[j])DFS(G,j);//若i到j之间存在连接且j未被遍历过，则开始以j为起点遍历j的所有相连顶点
}
```

该算法应用于从某一特定顶点开始遍历的情况。

**深度遍历算法**的实现：

```c++
int visited[MVNum];
void DFSTraverse(Graphmat G){
    int i;
    for(i=0;i<G.vernum;i++)visited[i]=0;//将所有顶点的visited定为0
    for(i=0;i<G.vernum;i++)
        if(!visited[i])DFS(G,i); //以每个顶点为DFS的起点，达到遍历的目的
}
```

### II.广度优先遍历(BFS)

```c++
int visited[MVNum];
void BFSTraverse(Graphmat G){
    int i,j;
    queue<int>q;
    for(i=0;i<G.vernum;i++)visited[i]=0; //初始化visited数组
    for(i=0;i<G.vernum;i++){
        if(!visited[i]){ //若遇到未被遍历的顶点
            visited[i]=1; //标记顶点i
            cout<<G.vers[i];
            q.push(i); //将i进入队列
            while(!q.empty()){
                i=q.front();
                q.pop(); //弹出i，开始进行以i为起点的所有边的遍历
                for(j=0;j<G.vernum;j++){ 
                    if(G.arcs[i][j]==1&&!visited[j]){ //若i和j顶点之间有连接且j未被visited
                        visited[j]=1; //标记顶点j
                        cout<<G.vers[j];
                        q.push(j); //将顶点j也压入队列中，开始以j为起点的所有边及其对应顶点的遍历
                    }
                }
            }
        }
    }
}
```

## 四.图的应用

### I.最小生成树

最小生成树一定含有n个顶点，n-1条边(必要条件)。

最小生成树算法很多都利用的**MST性质**(Minimunm Spanning Tree)

即两个独立的**等价集**之间的**最小权重路线**必定包含在**最小生成树**里。

**最小生成树算法**即寻找一条最短的路径(链)来将n个顶点全部遍历一遍。

#### 1.Prim算法

先确定一个顶点作为出发点，查找与该顶点相连的权重最小的边并连接，并不断重复该过程。

首先需要准备图的**带权邻接矩阵**。

```c++
#define MAXVEX 20
#define INFINITY 65535
void Prim(Graphmat G){
    int min,i,j,k;
    int vertex[MAXVEX]; //用于保存相关顶点的下标
    int lowcost[MAXVEX]; //保存树到各个顶点间的权值
    lowcost[0]=0; //初始化第一个权值为0，即v0加入了生成树，lowcost[i]=0即表示以i为下标的顶点已录入生成树
    vertex[0]=0; //第一个顶点的下标为0
    for(i=1;i<G.vernum;i++){
        lowcost[i]=G.arcs[0][i]; //初始化lowcost[i]，即树到各个顶点的距离此时为G.arcs[0][i]（即v0到各个顶点的距离）
        vertex[i]=0; //初始化路径全为0
    }      
    //以上为初始化过程
    for(i=1;i<G.vernum;i++){
        min=INFINITY; //初始化最小值为∞
        j=1; //j从1开始，因为v0已经纳入了树中
        k=0;
        while(j<G.vernum){ //循环全部顶点
            if(lowcost[j]!=0&&lowcost[j]<min){
                min=lowcost[j];
                k=j;
            } //取lowcost中的最小值，即此时离树最近的顶点的距离，k取该点的下标
            j++; //j进行循环
        }
        printf("(%d,%d)",vertex[k],k);//输出当前距离树最近的边
        lowcost[k]=0; //k为下标的顶点已纳入树中，不再参与比较
        for(j=1;j<G.vernum;j++){  //此时以k为新的出发点，更改lowcost的值
            if(lowcost[j]!=0&&G.arcs[k][j]<lowcost[j]){
                lowcost[j]=G.arcs[k][j]; //如果以k为出发点的带权长度小于原本的长度，则更新lowcost
                vertex[j]=k; //将下标为k的顶点存入vertex数组
            }
        }
    }
}
```



#### 2.Kruskal算法

先确定所有顶点，再将所有的边按其权重升序排序，以此按序列放入图中并保证不能出现环，直至所有顶点都被连接。

通过对**边的权值**进行比较，来确定最短的遍历路径。

Kruskal算法在输入时需要输入每条边的**起始顶点**，**终止顶点**，**权值**，且需要按权值**由大到小**排序。

首先定义**边**：

```c++
typedef struct Edge{
    int begin;
    int end;
    int weight;
}Edge;
```

Find函数的实现：

```c++
int Find(int *parent,int f){
    while(parent[f]>0)f=parent[f];
    return f;
}
```

Kruskal算法的实现：

```c++
void Kruskal(Graphmat G){
    int i,n,m;
    Edge edges[MAXEDGE]; //定义边集数组
   
    /*  此处用于将edges按权值大小排序，使用的时O(n2）的选择排序，可自行定义
    for(int i=0;i<edge;i++)
        for(int j=i;j<edge;j++)
        {
            if(edges[i].weight>=edges[j].weight){
                swap(edges[i].begin,edges[j].begin);
                swap(edges[i].end,edges[j].end);
                swap(edges[i].weight,edges[j].weight);
            }
        }
    */
    
    int parent[MAXVEX]; //用一组数组来判断是否存在回路
    for(int i=0;i<G.vernum;i++)parent[i]=0; //初始化parent数组为0
    for(int i=0;i<G.arcnum;i++){  //循环每一条边
        n=Find(parent,edges[i].begin);
        m=Find(parent,edges[i].end);  
        if(n!=m){   //若m和n不等，则此边没有与现成的生成树形成环路
            parent[n]=m; //将此边的结尾顶点放入下标为起点的parent中，表示该顶点已被录入生成树中
            cout<<'(' << edges[i].begin << ',' << edges[i].end << ')' << edges[i].weight;
        }
    }
}
```



### II.最短路径

在有向网中从**源点**到**终点**的多条路径中寻找一条各边权值之和最小的路径，称为**最小路径问题**。

**最短路径算法**与**最小生成树算法**的区别在于，**最小生成树算法**追求遍历，而**最短路径算法**要求起点和终点唯一。

#### 1.Dijkastra算法

Dijkastra算法用于解决从一点到另一点的最短路径问题(**单源最短路径问题**)，且应用场景仅局限于权边均为正数的图。

**T(n)=O(n^3^)**

在运用Dijkastra算法前，需要准备**带权邻接矩阵**来存储边及其权重的数值，初始矩阵值全为INFINITY，再逐个导入权重信息。

```c++
#define MAXVEX 9
#define INFINITY 65535
typedef int Patharc[MAXVEX];
typedef int ShortPathTable[MAXVEX]; //P用于存储最短路径，D用于存储带权长度，P[v]的值为前驱顶点的下标，D[v]表示v0到v的带权长度
void Dijkastra(Graphmat G,int v0,Patharc *P,ShortPathTable *D){
    int v,w,k,min;//v0是参考数，实际v0的值应为0，此处是为了方便理解
    int final[MAXVEX];//final[w]=1用于表示已求得v0到vw的最短路径
    for(v=0;v<G.vernum;v++){
        final[v]=0; //初始化final，0表示没有得到路径
        (*D)[v]=G.arcs[v0][v]; //将与v0点有连线的顶点加上权值
        (*P)[v]=0;
    } //初始化数据
    （*D)[v0]=0; //v0到v0的路径为0
    final[v0]=1; //v0已算入路径中
    for(v=1;v<G.vernum;v++){ //求v0到每个v顶点的最短路径，初始化时已将v0纳入路径，所以从1开始
        min=INFINITY; 
        for(w=0;w<G.vernum;w++){
            if(!final[w]&&(*D)[w]<min){
                k=w;
                min=(*D)[w];
            }//循环一次，寻找距离v0最近的点,k代表最近的点的下标,min取到最近的点路径的权值
        }
        final[k]=1;//循环一次后，final[k]=1表示k代表的点已经找到最短路径
        for(w=0;w<G.vernum;w++){
            if(!final[w]&&(min+G.arcs[k][w]<(*D)[w])) //若w顶点未被划入路径且目前的路径+路径末尾到w顶点的路径长度小于已知的路径长度
            {
                (*D)[w]=min+G.arcs[k][w]; //更新到w的新的最短路径
                (*P)[w]=k; //w的前驱改为k
            }
        }//修正v0到各个顶点间的距离
    }
}
```

#### 2.Floyd算法

Floyd算法用于解决**所有顶点间**的最短路径问题。

**T(n)=O(n^3^)**

存在公式：D^0^[v] [w] = min{D^-1^[v] [w] , D^-1^[v] [0] + D^-1^[0] [w] }      (D^-1^表示初始的邻接矩阵)

可以类比该公式认识到该算法的基本思想，通过**比较加入v~n~顶点后路径的长度与原路径的长度**来判断最短路径。

在使用Floyd算法前，仍需创建图的**带权邻接矩阵**。

```c++
#define MAXVEX 20
typedef int Pathmat[MAXVEX][MAXVEX];
typedef int ShortPathTable[MAXVEX][MAXVEX];
void Floyd(GraphMat G,Pathmat *P,ShortPathTable *D){//P[v][w]用于记录顶点v到任意w点的最短路径，D[v][w]用于记录最短路径的带权长度
    int v,k,w;
    for(v=0;v<G.vernum;v++){
        for(w=0;w<G.vernum;w++){
            (*D)[v][w]=G.arcs[v][w];
            (*P)[v][w]=w;
        }
    }//二重循环初始化两个二维数组，D中存储各个顶点间的带权距离，P中存储w本身
    for(k=0;k<G.vernum;k++){ //k表示中转顶点的下标
        for(v=0;v<G.vernum;v++){ //v表示起始顶点的下标
            for(w=0;w<G.vernum;w++){ //w表示终止顶点的下标
                if((*D)[v][w]>(*D)[v][k]+(*D)[k][w]){ //如果v经过k再到w的距离比v直接到w的距离更近，则更新D的值
                    (*D)[v][w]=(*D)[v][k]+(*D)[k][w]; //更新D中v到w的值
                    (*P)[v][w]=(*P)[v][k]; //路径设置经过下标为k的顶点
                }
            }
        }
    }
}
```

上述过程可以得到最短路径的**带权长度**，但要求出每个点到另一个点的**最短路径**，还需要写一个算法：

```c++
for(v=0;v<G.vernum;v++){
    for(w=v+1;w<G.vernum;w++){
        cout<<'v'<< v< <'-v'<< w <<'weight='<<D[v][w];\
        k=P[v][w];
        cout<<'path:'<< v;
        while(k!=w){
            cout<<'->'<< k;
            k=P[k][w];
        }
        cout<< '->' << w;
    }
    cout<<endl;
}
```

#### 3.Bellman-Ford算法

**Bellman-Ford算法**用于解决**Dijkstra算法**无法解决的存在负权边的图。

若存在**负环**则最短路径无意义(**不收敛**，无最小值)，因此要排除负环情况。

注意：进行几次松弛循环取决于经过顶点数最多的最短路径，

下列算法模版会返回Dist[i]，Pre[i]以及判断该图是否含有负环的bool值。

算法实现：

```c++
const int INIFINITY=0x3f3f3f3f;
int Dist[MVNum]; //用于存储起点到某顶点i的距离
int Pre[MVNum]; //用于存储某顶点在最短路径中的上一顶点
bool Bellman-Ford(Graphmat G,int v){ 	//v是该最短路径的起点
    for(int i=0;i<G.vernum;i++){
        Dist[i]=G.arcs[v][i]; //Dist[i]表示起点v到顶点i的路径长度
        if(Dist[i]<INFINITY)pre[i]=v; //若Dist[i]不为INIFINITY，则代表v可到达i，即i的上一顶点应初始化为v
        else Pre[i]=-1; //若v不可到达i，则定义Pre[i]=-1
    }
    Dist[v]=0;  //初始化结束
    
    for(int i=2;i<G.vernum-1;i++) //初始化已经进行了一次松弛，则松弛循环要减少一次操作
        for(int j=0;j<G.vernum;j++) //j为此次比较的路径的起点
            for(int k=0;k<G.vernum;k++) //k为此次比较的路径的终点
                if(Dist[k]>Dist[j]+G.arcs[j][k])
                {
                    Dist[k]=Dist[j]+G.arcs[j][k];
                    Pre[k]=j;
                }   	//松弛操作
    //接下来的操作用于判断该图中是否存在负圈
    bool flag=true;
    for(int j=0;j<G.vernum-1;j++)
        for(int k=0;k<G.vernum-1;k++)
            if(Dist[k]>Dist[j]+G.arcs[j][k]){ //若进行松弛循环后，还能进行松弛，则说明存在负圈
                flag=false;
                break;
            }
    return flag;  //返回bool值
}
```

#### 4.SPFA算法

**SPFA算法**是**Bellman-Ford算法**的优化版，通过引入**队列**来优化原有的松弛遍历，同样用于处理可能出现的带有负权的图。

但SPFA算法同样无法应用于带有负环的图。

下述算法实现能够返回最短路径的**带权距离**，并判断是否存在**负环**。

输入的邻接矩阵要求是带权邻接矩阵，i==j时权值为0。

基于邻接矩阵的SPFA算法：

```c++
#define INFINITY 0x3f3f3f3f
#define MVNum 1000
int Dist[MVNum]; //用于存储起点到各个顶点的最短距离
bool visited[MVNum]; //用于判断i顶点是否已放入队列
int sum[MVNum]; //用于记录各个顶点的入队次数，便于验证是否存在负圈
bool SPFA(Graphmat G){
    int i,j;
    memset(visited,false,sizeof(visited)); //初始化visited数组全为false
    memset(sum,0,sizeof(sum)); //初始化sum数组全为0
    fill(Dist,Dist+MVNum,INFINITY); //初始化Dist数组全为INIFINITY
    queue<int>q; //引入队列
    //此模版的顶点是从1开始计数的，注意输入格式
    q.push(1);
    Dist[1]=0;
    visited[1]=true; //下标为1的顶点进列，visited值改为true
    sum[1]=1;
    //初始化结束
    while(!q.empty()){
        int tmp=q.front(); 
        q.pop();
        visited[tmp]=false; //弹出队头元素并用队头元素来松弛距离
        for(i=1;i<=G.vernum;i++){
            if(G.arcs[tmp][i]!=INFINITY){ //判断队头元素tmp是否能够到达i
                if(Dist[i]>Dist[tmp]+G.arcs[tmp][i]) //以tmp为中间点松弛距离
                {
                    Dist[i]=Dist[tmp]+G.arcs[tmp][i];
                    if(visited[i]!=true){
                        q.push(i);
                        visited[i]=true;
                        sum[i]++;//若i还未入队，则将i入队并sum自增
                        if(sum>=G.vernum)
                            return false;//若i的松弛循环已经超出了顶点数，则图内必存在负圈
                    }
                }
            }
        }
    }
    return true; //不存在负圈则输出true
}
```

参考文献：https://blog.csdn.net/qq_44755403/article/details/90710553?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171429974216800225573132%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171429974216800225573132&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-90710553-null-null.142^v100^pc_search_result_base6&utm_term=%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5SPFA&spm=1018.2226.3001.4187

### III.拓扑结构

**有向无环图**，简称**DAG图**(Directed Acycline Graph)。

**AOV网**：用顶点表示活动，弧表示活动之间的优先制约关系。

**AOE网**：用弧表示活动，用顶点表示活动的开始或结束事件。

#### 1.AOV拓扑排序

##### a.基本概念

①在有向图中选择一个没有前驱的顶点并将其输出

②删掉该顶点和所有以它为尾的弧

③重复上边两步，在选择时优先选取序号较小者。直至所有顶点已输出或不存在没有前驱的顶点。

AOV网的拓扑序列**不是唯一**的。

##### b.代码实现

这里采用**邻接表**的形式实现**AOV网**及其**拓扑排序**

定义邻接表：

```c++
typedef struct EdgeNode{ //边表结点
    int vertex; //边所指向的终止顶点
    int weight; //该条边的权值
    struct EdgeNode *next; //指向next的指针
}EdgeNode;
typedef struct VertexNode{ //顶点表结点
    int in; //该顶点的入度,入度即指向该点的edge的总数
    int data; //该顶点的data值
    EdgeNode *firstedge; //指向EdgeNode的头指针
}VertexNode,VerList[MAXVEX];
typedef struct{ 
    VerList VerList;
    int vernum,arcnum; //记录顶点个数和边的个数
}graphList,*GraphList;
```

代码实现：

此算法是基于栈的算法，用于输出拓扑排序的同时判断此AOV网是否存在环，以bool的形式返回。

```c++
bool TopoSort(GraphList GL){
    EdgeNode *e;
    int i,k,tmp;
    int count=0;
    stack<int>s;
    for(int i=0;i<GL->vernum;i++)
        if(GL->VerList[i].in==0)s.push(i); //若某点入度为0，则入栈
        while(!s.empty()){ 
            tmp=s.top();
            s.pop;
            cout<<GL->VerList[tmp].data<<"->";
            count++; //统计输出的顶点的个数，便于输出bool值
            for(e=GL->VerList[tmp].firstedge;e;e=e->next){
                k=e->vertex; //k在这里用于省去书写
                if(!(--GL->VerList[k].in))s.push(k); //由于前驱顶点被输出，则将k的入度减1，若入度为0，则入栈，便于下次输出
            }
        }
    if(count<GL->vernum)return false; //一旦count<vernum，说明有顶点未被输出
    else return true;
}
```

此算法的时间复杂度**T(n)=O(n+e)**

#### 2.AOE关键路径

##### a.基本概念

**ve(vj)**表示事件vj的最早发生时间，**vl(vj)**表示事件vi的最迟发生时间，**e(i)**表示活动ai的最早开始时间，**l(i)**表示活动ai的最迟开始时间。

**l(i)-e(i)**表示完成活动ai的**时间余量**。

**关键活动**：关键路径上的活动，即l(i)-e(i)==0的活动。

若ai的开始事件为j，结束事件为k，则存在：

①**e(i)=ve(j)**

②**l(i)=vl(k)-w~j,k~**

##### b.代码实现

首先需要用到**拓扑排序算法**：

```c++
int *early,*late; //声明事件最早发生时间和事件最晚发生时间，即顶点的发生时间
stack<int>s2;//s2用于存储拓扑序列，便于求关键路径使用
bool TopoSort(GraphList GL){
    EdgeNode *e;
    int i,k;
    int count=0;
    stack<int>s1;
    for(i=0;i<GL->vernum;i++)
        if(GL->VerList[i].in==0)s1.push(i);//若入度为0，则入栈
    early=new int[GL->vernum];
    for(i=0;i<GL->vernum;i++)early[i]=0; //初始化时间最早发生时间为0
    while(!s1.empty()){
        int tmp=s1.top();
        s1.pop();
        count++;
        s2.push(tmp);//将弹出的顶点压入关键路径栈s2中
        for(e=GL->VerList[tmp].firstedge;e;e=e->next){
            k=e->vertex;
            if(!(--GL->VerList[k].in))s1.push(k);//由于tmp被弹出，则tmp指向的顶点入度减1，并检查是否为0，若为0则入栈
            if((early[tmp]+e->weight)>early[k])//最早发生时间要求取所有子顶点中权值最大的路线
                early[k]=early[tmp]+e->weight;//若tmp的最早发生事件加上某与之相连的顶点的权重和大于已有的k的最早发生时间，则更新k的最早发生时间
        }
    }
    if(count<GL->vernum)return false;
    else return true;
}
```

**关键路径算法**的代码实现：

```c++
void CriticalPath(GraphList GL){
    EdgeNode *e;
    int i,k,j;
    int ete,lte; //声明活动最早发生时间和最晚发生时间，即边的发生时间
    TopoSort(GL);//求拓扑序列，计算early数组和s2的值
    late=new int[GL->vernum];//创建事件最晚发生时间数组
    for(i=0;i<GL->vernum;i++)late[i]=etv[GL->vernum-1];//初始化数组late;
    while(!s2.empty()){
        int tmp=s2.top();
        s2.pop(); //弹出栈顶元素
        for(e=GL->VerList[tmp].firstedge;e;e=e->next){
            k=e->vertex;
            if(late[k]-e->weight<late[tmp])
                late[tmp]=late[k]-e->weight; //计算事件最晚发生时间，要求最晚发生时间取更小的值
        }
    }
    for(j=0;j<GL->vernum;j++){
        for(e=GL->VerList[j].firstedge;e;e=e->next){ //遍历所有顶点
            k=e->vertex;
            ete=early[j]; //活动最早发生时间即事件最早发生时间
            lte=late[k]-e->weight; //活动最晚发生时间应为事件最早发生时间减去以该顶点为终点的边的权值
            if(ete=lte) //若最早发生时间和最晚发生时间相等，则该顶点位于关键路径上
                printf("<v%d,v%d> length=%d,"GL->VerList[j].data,GL->VerList[k].data,e->weight);
        }
    }
}
```

