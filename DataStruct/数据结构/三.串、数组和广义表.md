[TOC]

# 三.串、数组和广义表

## 一、字符串(String)

### I.基础概念

**子串**：串中任意个连续字符组成的子序列(含空串)称为该串的子串。

**字符位置**：字符在序列中的序号。

**子串位置**：子串的第一个字符在主串中的位置。

**空格串**：字符全为空格的串。

根据存储结构可将串分为**顺序串**和**链串**。

### II.顺序串

#### 1.定义

```c++
#define MAXLEN 255
typedef struct{
    char ch[MAXLEN+1];
    int length;
}SqString;
```

### III.链串(块链结构)

#### 1.定义

```c++
#define CHUNKSIZE 80
typedef struct Chunk{
    char ch[CHUNKSIZE];
    struct Chunk *next;
}Chunk;

typedef struct{
    Chunk *head,*tail; //串的头指针和尾指针
    int curlen; //串的当前长度
}LString; //块链结构
```

### IV.串的模式匹配算法

#### 1.BF(BruteForce)算法

```C++
int BFIndex(SqString S,SqString T){
    int j=1,i=1;
    while(i<=S.length&&j<=T.length){
        if(S.ch[i]==T.ch[i]){
            ++i;
            ++j;
        }
        else{
            i=i-j+2;//回溯
            j=1;
        }
    }
    if(j>=T.length)return i-T.length;//返回第一个匹配的字符的下标
    else return 0;
}
```

若S.length=n，T.length=m，则时间复杂度T(n)=O(n*m)。

#### 2.KMP算法

**next[j]**的取值：

1.当j=1时，next[j]=0

2.当子串的前k-1个元素与P[j]前的k-1个元素完全相等时，next[j]取k的最大值

3.若不满足上方的情况时，next[j]=1

```c++
void getNext(SqString T,int &next[]){
    int i=1,next[1]=0;j=0;
    while(i<T.length){
        if(j==0||T.ch[i]==T.ch[j]){
            ++i;
            ++j;
            next[i]=j;
        }
        else
            j=next[j];
    }
}
```

有了next数组后的KMP算法：

```c++
int KMPIndex(SqString S,SqString T){
    int j=1,i=1;
    while(i<=S.length&&j<=T.length){
        if(j==0||S.ch[i]==T.ch[i]){
            i++;
            j++;
        }
        else{
            j=next[j];//i不回溯，j去next[j]的值
        }
        if(j>T.length)return i-T.length;
        else return 0;
    }
}
```

改进next数组得到nextval[]，关键在于判断next[j]是否与j指向的字符一致，若一致则再去next[next[j]]，直至不同或回到串首。

```c++
void getNextval(SqString T,int &nextval[]){
    int i=1,nextval[1]=0,j=0;
    while(i<T.length){
        if(j==0||T.ch[i]==T.ch[j]){
            i++;
            j++;
            if(T.ch[i]!=T.ch[j])nextval[i]=j;
            else nextval[i]=nextval[j];
        }
        else j=nextval[j];
    }
}
```

## 二.数组

对于n维数组，其各维元素个数为m~1~，m~2~，m~3~，......，m~n~

则下标为i~1~，i~2~，i~3~，......，i~n~的数组元素的存储位置为：

**LOC(i~1~，i~2~，i~3~，...，i~n~)=a+(Σ(j=1→n-1)i~j~×Π(k=j+1→n)m~k~)+i~n~**

### I.压缩矩阵

 特殊的矩阵，如对称矩阵，对角矩阵，三角矩阵，稀疏矩阵等，可采取压缩矩阵的方法存储。 

#### 1.对称矩阵

存在如下性质：**a~ij~=a~ji~**

以行列为主序时，可将元素放在一个一维数组**sa[n(n+1)/2]**中。

#### 2.三角矩阵

需要的空间：n(n+1)/2

上三角矩阵：i>=j时，k=[(i-1)×(2n-i+2)/2]+j+i+1

​						 i<j时，k=[n(n+1)/2]+1

下三角矩阵：i>=j时，k=[i×(i-1)/2]+j

​						 i<j时，k=[n(n+1)/2]+1

#### 3.稀疏矩阵

##### a.三元组法

M由三元组(i,j,a~ij~)唯一确定矩阵的非零单元，三元组和矩阵维数可唯一确定一个稀疏矩阵。

```c++
typedef struct trimat{
    ElemType data;
    int i;
    int j;
    struct trimat *next;
}trimat;
```

##### b.十字链表法

结构体中除了安排三元组的三个元素外，还有right和down

其中**right**用于链接同一行中下一个非零元素

其中**down**用于链接同一列中下一个非零元素

```c++
typedef struct trimat{
    ElemType data;
    int i;
    int j;
    struct trimat *right;
    struct trimat *down;
}trimat;
```

## 三.广义表/列表

**原子**即广义表内的最小存储单元，可以是一个整型或是字符。

习惯上大写字母表示**广义表**，小写字母表示**原子**。

**表头**：若LS非空，则其第一个元素a~1~就是表头。

**表尾**：除表头外的其他元素组成的**广义表**，而不能是**原子**。
