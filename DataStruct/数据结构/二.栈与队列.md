[TOC]



# 二.栈与队列

## 一.栈

### I.基础概念

栈的操作具有**后进先出**(LIFO)的特性，从队尾插入，队尾删除。

其中表尾称为**栈顶**(Top)，表头称为**栈底**(Base)。

将元素从栈顶插入，叫做**入栈**(Push)。

从栈顶删除最后一个元素，叫做**出栈**(Pop)。

栈已满，又要压入元素导致的出错，称为**上溢**(Overflow)。

栈已空，又要弹出元素导致的出错，称为**下溢**(Underflow)。



#### 1.定义**顺序栈**(SqStack):

```c++
#define MAXSIZE 100
#define ERROR 0
#define OK 1
#define OVERFLOW -2
typedef int SElemType;
typedef struct{
    SElemType *base;
    SElemType *top;
    int StackSize;
}SqStack;
```

#### 2.定义**链栈**(StackLink):

```c++
typedef struct StackNode{
    SElemType data;
    struct StackNode *next;
}StackNode,*LinkStack;
LinkStack S;
```

### II.顺序栈的基础ADT函数

#### 1.初始化

```c++
Status InitStack(SqStack &S){
    S.base=new SElemType[MAXSIZE];
    if(!S.base) exit(OVERFLOW);
    S.top=S.base;
    S.StackSize=MAXSIZE;
    return OK;
}
```

#### 2.判断空栈

```c++
Status IsEmpty(SqSatack &S){
    if(S.top==S.base)return TRUE;
    else return FALSE;
}
```

#### 3.求栈长

```c++
int StackLength(SqStack &S){
    return S.top-S.base;
}
```

#### 4.清空顺序栈

```c++
Status ClearStack(SqStack &S){
    if(S.base)S.top=S.base;
    return OK;
}
```

#### 5.销毁顺序栈

```c++
Status DestroyStack(SqStack &S){
    if(S.base){
        delete S.base; 	//内存被清除了，但指针还存在
        S.StackSize=0;
        S.base=S.top=NULL; 	//使指针指向NULL，防止出现野指针
    }
    return OK;
}
```

#### 6.入栈(Push)

```c++
Status Push(SqStack &S,SElemType e){
    if(S.top-S.base==S.StackSize)return ERROR;
    *S.top++=e;
    return OK;
}
```

#### 7.出栈(Pop)

```c++
Status Pop(SqStack &S,SElemType e){
    if(S.top==S.base)return ERROR;
    e=*--S.top;
    return OK;
}
```

### III.链栈的基础ADT函数

#### 1.初始化

```c++
Status StackEmpty(LinkStack &S){
    S=NULL;
    return OK;
}
```

#### 2.判断空栈

```c++
Status IsEmpty(StackLink &S){
    if(S==NULL)return TRUE;
    else return FALSE;
}
```

#### 3.入栈(Push)

```c++
Status Push(LinkStatus &S,SElemType e){
    p=new StackNode;
    p->data=e;
    p->next=S;
    S=p;
    return OK;
}//S为栈顶的指针
```

#### 4.出栈(Pop)

```c++
Status Pop(LinkStack &S,SElemType &e){
    if(!S)return ERROR; //判断是否为空栈
    e=S->data; 	//取出栈顶的值
    p=S;	
    S=S->next; //S下移
    delete p; 	//删除p指针，由于p为函数内变量，无需改为NULL
    return OK;
}
```

#### 5.取栈顶元素

只取栈顶元素而不删除栈顶指针

```c++
SElemType Gettop(LinkStack &S){
    if(S)return S->data;
}
```

## 二.队列

### I.基础概念

队列的操作具有**先进先出**(FIFO)的特性，从队尾插入，队头删除。

表尾即a~n~端，称为**队尾**。表头即a~1~端，称为**队头**。

插入元素称为**入队**，删除元素称为**出队**。

通过取余运算实现循环队列，避免假溢出情况。
$$
Q.rear=(Q.rear+1)~(mod)~MAXQSIZE
$$
判断**队空**：
$$
front==rear
$$
判断**队满**：
$$
(rear+1)~(mod)~MAXQSIZE==front
$$


#### 1.定义顺序循环队列

```c++
#define MAXSIZE 100
typedef struct{
    QElemType *base;
    int front; 	//头指针
    int rear;	//尾指针
}SqQueue;
```

#### 2.定义链式队列

```c++
#define MAXSIZE 100
typedef struct QNode{
    QElemType data;
    struct QNode *next;
}QNode,*QueuePtr;

typedef struct{
    QueuePtr front;
    QueuePtr rear;
}LinkQueue;
```



### II.顺序循环队列的基础ADT函数

#### 1.初始化

```c++
Status InitQueue(SqQueue &Q){
    Q.base=new QElemType[MAXSIZE];
    //Q.base=(QElemType*)malloc(MAXSIZE*sizeof(QElemType));
    if(!Q.base)exit(OVERFLOW);
    Q.front=Q.rear=0;
    return OK;
}
```

#### 2.求列长

```c++
int QueueLength(SqQueue Q){
    return ((Q.rear-Q.front+MAXSIZE)%MAXSIZE);
}
```

RETURN的值可以认为是取绝对值，指出了一种不需要math库函数的取绝对值方法。

#### 3.入队

```c++
Status EnQueue(SqQueue &Q,QElemType e){
    if((Q.rear+1)%MAXSIZE==Q.front)return ERROR;
    //判断队列是否为队满状态
    Q.base[Q.rear]=e;
    Q.rear=(Q.rear+1)%MAXSIZE;
    return OK;
}
```

#### 4.出队

```c++
Status DeQueue(SqQueue &Q,QElemType &e){
    if(Q.rear==Q.front)return ERROR;//判断队空
    e=Q.base[Q.front];
    Q.front=(Q.front+1)%MAXSIZE;
    return OK;
}
```

### III.链式队列的基础ADT函数

#### 1.初始化

```c++
Status InitQueue(LinkQueue &Q){
    Q.front=Q.rear=new QueuePtr;
    if(!Q.front)exit(OVERFLOW);
    Q.front->next=NULL;
    return OK;
}
```

#### 2.销毁链式队列

```c++
Status DestroyQueue(LinkQueue &Q){
    QueuePtr p;
    while(Q.front){
        p=Q.front->next;
        delete Q.front;
        Q.front=p;
    }//存在循环，若Q.front不为空，则删除Q.front指向的QNode
    return OK;
}
```

#### 3.入队

```c++
Status EnQueue(QNode &Q,QElemType e){
    QueuePtr p;
    p=new QNode;
    if(!p)exit(OVERFLOW);//判断是否成功分配
   	p->data=e;
    p->next=NULL;//队尾插入，则next指向NULL
    Q.rear->next=p;
    //Q.rear此时指向p的前一个节点，即让前一个节点的next指向p
    Q.rear=p;//将Q.rear指向p
    return OK;
}
```

#### 4.出队

```c++
Status DeQueue(QNode &Q,QElemType &e){
    QueuePtr p;
    if(Q.front==Q.rear)return ERROR;
    p=Q.front->next;//首元节点是Q.front->next
    e=p->data;
    Q.front->next=p->next;
    if(Q.rear==p)Q.rear=Q.front; 
    delete p;
    return OK;
}
```

