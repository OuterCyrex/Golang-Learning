[TOC]

# 一.线性表和链表

## 1.线性表

定义一些函数结果状态代码

```c++
#define TRUE 1
#define FALSE 0
#define OK 1
#define ERROR 0 	//数值不合法返回ERROR
#define INFEASIBLE -1
#define OVERFLOW -2  //数值溢出时返回OVERFLOW
const int MAXSIZE=100010;
typedef int Status;	//用于特指函数返回值
typedef int ElemType;	//线性表内数据的数据类型
```

首先定义一个线性表

```c++
typedef struct{
    ElemType *Elem;
    int Length;
}SqList;
```

### I.初始化

```c++
Status InitList_Sq(SqList &L)
{
    L.Elem=new ElemType[MAXSIZE];
    //或L.Elem=(ElemType*)malloc(sizeof(ElemType)*MAXSIZE);
    if(!L.Elem)exit(OVERFLOW);//若分配失败，则返回OVERFLOW
    L.length=0;//初始化长度为0
    return OK;
}
```

其中!L.Elem指：若new/malloc函数未成功分配，则L.Elem的值为NULL，!NULL=TRUE，使if成功检测，退出程序并返回OVERFLOW。

### II.基础ADT函数

#### 1.销毁线性表

```c++
void DestroyList(SqList &L)
{
    if(L.Elem)delete L.Elem;
    //或free(L.Elem);
}
```

L.Elem用于检测线性表SqList是否存在，若存在则释放其存储空间。

#### 2.清空线性表

```c++
void ClearList(SqList &L)
{
    L.length=0;
}
```

#### 3.长度函数和空表判断

```c++
int GetLength(SqList &L)
{
    return (L.length);
}
int IsEmpty(SqList &L)
{
    if(L.length==0)return 1;
    else return 0;
}
```

#### 4.查找函数

##### a.按序查找

```c++
Status GetElem(SqList &L,int i,ElemType &e)
{
    if(i<1&&i>L.length)return ERROR;//判断合法性
    e=L.elem[i-1];
    return OK;
}
```

线性表的这种随用随取的性质叫做**==随机存取性==**。

##### b.按值查找

```c++
int LocateElem(SqList &L,ElemType e){
    int i=0;
    while(i<L.length&&L.Elem[i]!=e)i++;
    if(i<L.length)return i+1;
    return 0;
}
```

#### 5.插入与删除元素

##### a.在第i个位置插入元素

```c++
Status ListInsert(SqList &L,int i.ElemType e){
    if(i>L.length+1||i<1)return ERROR;//判断数值合法性
    if(length==MAXSIZE)return ERROR;//判断是否可插入数值
    for(int j=L.length-1;j>=i-1;j--)
        L.Elem[j+1]=L.Elem[j];//i及后边所以的元素后移
    L.Elem[i-1]=e;
    L.length++;
    return OK;
}
```

##### b.在第i个位置删除元素

```c++
Status ListDelete(SqList &L,int i)
{
    if(i<1||i>L.length)return ERROR;//判断合法性
    for(int j=i;j<=L.length-1;j++)
        L.Elem[j-1]=L.Elem[j];//i后的所有元素前移
    L.length--;
    return OK;
}
```

### III.总结

![](C:\Users\Administrator\Desktop\虚动智能\数据结构\pic\QQ图片20240412115501.png)

## 2.链表

### I.单链表

#### 1.基础概念

![image-20240412145017892](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240412145017892.png)

表示空表：

1.有**头结点**时，头结点的指针域为空。

2.无**头结点**时，头指针为空。

==定义链表：==

```c++
typedef int ElemType;  //定义数据类型
typedef struct LNode{
    ElemType data;		//数据域
    struct LNode *next;		//指针域
}Lnode,*LinkList;	//LinkList指向LNode

LinkList L;//定义链表L
LNode *p,*s; //定义节点指针p

p=L;	//p指向头结点
s=L->next;	//s指向首元结点
p=p->next;	//p指向下一节点
```

#### 2.链表初始化

```C++
Status InitList(LinkList &L)
{
    L=new LNode;
    //或L=(LinkList)malloc(sizeof(LNode));
    L->next=NULL;
    return OK;
}
```

以上过程生成了一个头结点。

#### 3.判断空链表和链表的销毁

```c++
int IsEmpty(LinkList L){
	if(L->next)return 0;
    else return 1;
}//判断链表是否为空

Status DestroyList(LinkList &L){
    LNode *p;//或LinkList p;
    while(L){
        p=L;	//p是中间指针变量，用于删除L的原地址
        L=L->next;
        delete p;//或free(p);
    }
    return OK;
}//销毁链表

Status ClearList(LinkList &L){
    LNode *p,*q;//要保留L指针，所以需要另置一个中间变量
    p=L->next;//p指向首元结点
    while(p){
        q=p->next;//q指向p的下一位
        delete p;//删除p所指向的地址
        p=q;//p指向下一位
    }
    L->next=NULL;
    return OK;
} 	//清空链表
```

注意：L指向头结点，L->next指向第一个节点a~1~(首元结点)。

#### 4.求链表表长

```c++
int ListLength(LinkList &L){
    LNode *p; //中间变量p
    int i=0;
    while(p){
        i++;
        p=p->next; //指针移动
    }
    return i;
}
```

由此可见，链表并不具有随机存取性。

#### 5.按值查找和按序查找

按序查找：(求第i个节点的值)

```c++
int SearchList(LinkList &L,int i，ElemType &e){
    LNode *p;
    p=L->next;
    int j=1;
    //此处定义一个新计数器的目的：验证i的合法性，防止i不合法导致程序错误
    while(p&&j<i){
       	p=p->next;
        ++j;	//和j++一个意思
    }
    if(!p||j>i)return ERROR; //第i个元素不存在；
    e=p->data; //将第i个元素的值赋给e
    return OK;
}
```

按值查找：(求与e相等的节点的序号)

```c++
int LocateList(LinkList &L,ElemType e){
    LNode *p;
    int j=1;
    p=L->next;
    while(p&&p->data!=e){
        p=p->next;
        ++j;
    }
    if(!p)return NULL; //若无该元素，则返回空(NULL)
    return j;
}
```

#### 6.插入元素

在第i个节点后插入一个新的节点：

```c++
Status InsertList(LinkList &L,int i,ElemType e){
    LNode *p,*s;
    int j=0;
    p=L;
    while(p&&i-1>j){
        p=p->next;
        ++j;
    }		//此时若查找到，则p是指向第i-1个节点
    if(!p||j>i-1)return ERROR; //验证合法性
    s=new LNode; //借用新空间，也可用malloc
    s->data=e;
    
    s->next=p->next;
    p->next=s;	//指针的转接，令p指向s，s指向原本p的指向
    
    return OK;
}
```

#### 7.删除元素

删除第i个节点:

```c++
Status RemoveList(LinkList &L,int i,ElemType &e){
    LNode *p,*q;
    int j=1;
    p=L->next;
    while(p->next&&j<i-1){
        p=p->next;
        ++j;
    }
    if(!(p->next)||j>i-1)return ERROR;
    //上述过程用于查找i的前一位以及判断合法性
    
    q=p->next; //令q指向第i个节点(即要删除的节点)
    p->next=q->next; //第i-1个节点指向第i+1个节点
    e=q->data; //取出第i个节点的数值
    delete q; //释放q的空间
    
    return OK;
}
```

#### 8.链表的建立

##### a.头插法

采用倒序法插入，要求输入的数组以从后向前的形式进行插入。

```c++
void HeadInsert(ElemType e)
{
    p=new LNode;
    p->data=e;
    p->next=L->next;
    L->next=p;                                         
}
```

插入一整个数组：

```c++
void HeadCreate(LinkList &L,int n)//n是链表的长度
{
    LNode *p;
    L=new LNode;
    L->next=NULL;
    while(n--){
        p=new LNode;
        cin >> p->data;
        p->next=L->next;
        L->next=p;
    }
}
```

##### b.尾插法

```c++
void TailCreate(LinkList &L,int n){
    LNode *p,*r;
    L=new LNode;
    L->next=NULL;
    r=L;
    while(n--){
        p=new LNode;
        cin >> p->data;
        p->next=NULL;
       	r->next=p;
        r=r->next;//即r=p;
    }
}
```

##### c.输出链表

```c++
void printfList(LinkList &L){
    LNode *p;
    p=L->next;
    while(p){
        cout << p->data << ' ';
        p=p->next;
    }
}
```

### II.循环链表

#### 1.插入操作

```c++
void CircleList(LinkList &L,int n){
    LNode *p;
    L=new LNode;
    L->next=L;
    while(n--){
        p=new LNode;
        cin >> p->data;
        p->next=L->next;
        L->next=p;
    }
}
```

### III.双链表

#### 1.基础定义

```c++
typedef struct DBLNode{
    ElemType data;
    struct DBLNode *prior,*next;
}DBLNode,*DBLinkList;
```

#### 2.插入操作

在第i个节点前插入新节点

```c++
Status InsertDBList(DBLinkList &L,ElemType e,int i){
    LNode *p,*s;
    int j=1;
    p=L->next;
    while(p&&i>j){
        p=p->next;
        ++j;
    }
    if(!p||j>i)return ERROR;
    
    s=new DBLNode;
    s->data=e;
    s->prior=p->prior;
    p->prior->next=s;
    s->next=p;
    p->prior=s;
    
    return OK;
}
```

#### 3.删除操作

删除第i个节点

```c++
Status DeleteDBList(DBLinkList &L,int i,ElemType &e){
    LNode *p;
    p=L->next;
    int j=1;
    while(p&&i>j)j++;
    if(!p||i<j)return ERROR;
    
    e=p->data;
    p->prior->next=p->next;
    p->next->prior=p->prior;
    delete p;
    return OK;
}
```

## 3.总结与比较

#### 1.顺序表与链表的比较

![](C:\Users\Administrator\Desktop\虚动智能\数据结构\pic\QQ图片20240414113528.png)

#### 2.链表的合并

```c++
void MergeDBList(LinkList &La,LinkList &Lb,LinkList &Lc){
    DBLNode *pa,*pb,*pc;
    pa=La->next,pb=Lb->next;
    pc=Lc=La;
    
    while(pa&&pb){		//当La和Lb还未结束时循环
    	if(pa->data<=pb->data){
            pc->next=pa; 	//将pa的值接入链表Lc
            pc=pa;		//Lc指针向后移动,也可写作pc=pc->next;
            pa=pa->next; 	//pa指针移动
        }
    	else{
            pc->next=pb;
            pc=pb;
            pb=pb->next;  	//同理
        }
    }
    pc->next=pa?pa:pb;
    //即if(pa)pc->next=pa; else pc->next=pb;
    delete Lb;
}
```

