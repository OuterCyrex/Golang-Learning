[TOC]

# 四.树和二叉树

## 一.基本术语

树型结构属于非线性结构，节点之间有分支，且具有层次关系。

![](C:\Users\Administrator\Desktop\虚动智能\数据结构\pic\QQ图片20240417195521.png)

### I.树的相关定义

树的本质是一种**广义表**。

**根结点**：非空树中无前驱结点的结点。

**叶子结点**：树的终端节点。

结点的**度**：结点所拥有的子树的个数。
树的**度**：树内各结点的度的最大值。

树的**深度**：树中结点的最大层次。

**有序树**：树中各结点的各子树从左到右有次序，反之则为**无序树**。

**森林**：m棵互不相交的树的集合。



### II.结点相关定义

结点的子树的根称为该结点的**孩子**，该结点称为孩子的**双亲**。

有共同**双亲**的结点称为**兄弟**结点

双亲在同一层的结点称为**堂兄弟**结点。

结点的**祖先**：从根到该结点所经过的分支上的所有的结点，反过来称为**子孙**。



## 二.二叉树(BinaryTree)

每个结点最多有两个**孩子**(child)，且**子树**(subtree)有左右之分，其次序不能颠倒。

**二叉树**本质不是树，但可以认为是严格要求左右次序的树。

### I.二叉树的性质

在二叉树的第i层上至多有==2^(i-1)==个结点。

**深度**为k的二叉树至多有==2^k-1==个结点。

若叶子结点的个数为n~0~，则度为2的结点数==n~2~=n~0~-1==;

#### 1.满二叉树

一棵深度为k且有==2^k-1==个结点的二叉树称为**满二叉树**，即各结点都有两个**孩子**，**满二叉树**的叶子结点有==2^(k-1)==个。

#### 2.完全二叉树(Complete BinaryTree)

![](C:\Users\Administrator\Desktop\虚动智能\数据结构\pic\QQ截图20240417210420.png)

各个结点的序号与满二叉树的序号一一对应的树称为**完全二叉树**。

具有n个结点的**完全二叉树**的深度为==floor(log~2~n)+1==。



结点数为n的**完全二叉树**的结点序号的性质：

![QQ截图20240417211521](C:\Users\Administrator\Desktop\虚动智能\数据结构\pic\QQ截图20240417211521.png)

### II.二叉树的存储结构

#### 1.顺序存储结构

```c++
#define MAXTSIZE 100
typedef ElemType SqBiTree[MAXSIZE];
SqBiTree bt;
```

#### 2.链式存储结构

二叉链表：

```c++
typedef struct BiNode{
    ElemType data;
    struct BiNode *lchild;
    struct BiNode *rchild;
}BiNode,*BiTree;
```

三叉链表：

```c++
typedef struct TriNode{
    ElemType data;
    struct TriNode *lchild;
    struct TriNode *rchild;
    struct TriNode *parent;
}TriNode,*TriTree;
```

### III.遍历二叉树

遍历二叉树的途径分为三种：**先序遍历**、**中序遍历**、**后序遍历**和**层次算法**。

**先序遍历**：先根再左最后右(DLR)。==根节点→左子树→右子树==

**中序遍历**：先左再根最后右(LDR)。==左子树→根节点→右子树==

**后序遍历**：先左在右最后根(LRD)。==左子树→右子树→根节点==

![](C:\Users\Administrator\Desktop\虚动智能\数据结构\pic\QQ截图20240418221028.png)

通过先序和中序序列，或后序和中序序列可以唯一的确定一棵**二叉树**。(先序和后序的组合不能唯一确定，必须要==中序==和其余一种才可唯一确定)

#### 1.先序遍历

递归算法：

```c++
Status PreOrder(BiTree &T){
    if(!T)return OK;
    else{
        visit(T);	//可以是任意操作，如输出
        PreOrder(T->lchild);
        PreOrder(T->rchild);
    }
}
```

#### 2.中序遍历

##### I.递归算法：

```c++
Status InOrder(BiTree &T){
    if(!T)return OK;
    else{
        InOrder(T->lchild);
        visit(T);
        InOrder(T->rchild);
    }
}
```

##### II.非递归算法(用栈模拟)：

```c++
Status InOrder(BiTree &T){
    BiTree p;
    StackNode *S;
    InitStack(S);//创立一个栈
    p=T;
    while(p||!StackEmpty(S))//p为空且栈为空时停止循环
    {
        if(p){
            Push(S,p);
            p=p->lchild;
        }//若p不为空，则将p的值插入栈，指针向lchild移动
        else{
            Pop(S,q);
            cout <<q->data;
            p=q->rchild;
        }//若p为空，则输出根节点并转向rchild
        return OK;
    }
}
```



#### 3.后序遍历

```c++
Status PostOrder(BiTree &T){
    if(!T)return OK;
    else{
        PostOrder(T->lchild);
        PostOrder(T->rchild);
        visit(T);
    }
}
```

#### 4.层次遍历

##### 1.自行构建队列

```c++
typedef	struct{
    BTNode data[MAXSIZE];
    int front,rear;
}SqQueue;

void LevelOrder(BiTree &B){
    BTNode *p;
    SqQueue *qu;
    InitQueue(qu);	//队列初始化
    enQueue(qu,B);	//将根插入队列
    while(!IsEmpty(qu)){
        deQueue(qu,p); //输出队头，p会指向被出队的队头元素
        cout << p->data;
        if(p->lchild)enQueue(qu,p->lchild);//若lchild存在，则将lchild入队
        if(p->rchild)enQueue(qu,p->rchild);//若rchild存在，则将rchild入队
    }//队列为空时结束循环
}
```

##### 2.使用C++标准库函数**queue<type>**

###### a.queue函数的定义

库：#include<queue>;

创建队列：queue<数据类型>队列名称

入栈出栈：队列名称.push(数据)，队列名称.pop()；

实例:

```c++
#include<queue>
queue<int>q;
q.push(1);
q.push(2);
q.pop();
cout<<q.front();
//输出结果：2
```

###### b.代码实现

```c++
void LevelOrder(BiTree &B){
    BiNode *p;
    queue<BiTree>q;
    q.push(B);
    while(!q.empty()){
    	p=q.front();
        q.pop();
        cout<<p->data;
        if(p->lchild)q.push(p->lchild);
        if(p->rchild)q.push(p->rchild);
    }
}
```

### IV.线索二叉树(Threaded Binary Tree)

若某个结点lchild为空，则将lchild的指针域改为指向其**前驱**

若某个结点rchild为空，则将rchild的指针域改为指向其**后继**

```c++
typedef struct BiThNode{
    ElemType data;
    bool ltag,rtag;
    struct BiThNode *lchild,*rchild;
}BiThNode,*BiThTree;
```



### V.二叉树相关数据的计算

#### 1.先序建立二叉树

```c++
Status CreateBiTree(BiTree &T){
    char ch;
    cin>>ch;
    if(ch=='#')T=NULL;
    else{
        if(!(T=new BiTNode))exit(OVERFLOW);
        T->data=ch;
        CreateBiTree(T->lchild);
        CreateBiTree(T->rchild);
    }
    return OK;
}
```

#### 2.复制二叉树

```c++
int Copy(BiTree T,BiTree &NewT){
    if(!T){ 	//若T为空则NewT为空，递归的终止条件
        NewT=NULL;
        return 0;
    }
    else{	
        NewT=new BiNode;
        NewT->data=T->data;
        Copy(T->lchild,NewT->lchild);
        Copy(T->rchild,NewT->rchild);
    }
}
```

#### 3.计算二叉树深度

```c++
int Depth(BiTree T){
    int m,n;
    if(!T)return 0; //终止条件
    else{
        m=Depth(T->lchild);
        n=Depth(T->rchild);
        return (m>n?m:n)+1; //+1实现数值增加，加上的是根/叶！
    }
}
```

#### 4.计算结点总数

```c++
int NodeCount(BiTree T){
    if(!T)return 0; //终止条件
    else
        return NodeCount(T->lchild)+NodeCount(T->rchild)+1;
    //某结点下的结点数=左子树结点数+右子树结点数+根。
}
```

#### 5.计算叶子结点的个数

```c++
int LeafCount(BiTree T){
    if(!T)return 0;
    else if(!T->lchild&&!T->rchild)return 1;
    else return LeafCount(T->lchild)+LeafCount(T->rchild);
}
```

### VI.样例

先序输入和输出二叉树

输入数据：ABC#DE#G##F####

```c++
#include<iostream>
using namespace std;
#define ERROR 0
#define OVERFLOW -2
#define OK 1
typedef char ElemType;
typedef int Status;
typedef struct BiNode{
    ElemType data;
    struct BiNode *lchild,*rchild;
}BiNode,*BiTree;
Status CreateBiTree(BiTree &T){
    char ch;
    cin>>ch;
    if(ch=='#')T=NULL;
    else{
        if(!(T=new BiNode))exit(OVERFLOW);
        T->data=ch;
        CreateBiTree(T->lchild);
        CreateBiTree(T->rchild);
    }
    return OK;
}
Status PreOrder(BiTree &T){
    if(!T)return OK;
    else{
        cout<<T->data<<' ';
        PreOrder(T->lchild);
        PreOrder(T->rchild);
    }
    return OK;
}

int main(void){
    BiTree L;
    CreateBiTree(L);
    PreOrder(L);
}
```

## 三.树和森林

### I.树的存储结构

#### 1.双亲表示法

```c++
typedef struct TreeNode{
    ElemType data;
    int parent;
}TreeNode
typedef struct PTree{
    TreeNode Tree[MAXSIZE];
    int r,n; //根结点的位置和结点的个数
}PTree;
```

#### 2.孩子链表

```c++
typedef struct kidNode{
    int child; //child存储的是该结点子树的数组坐标
    struct kidNode *next;
}*Childptr;
//孩子结点结构
typedef struct parNode{
    ElemType data;
    Childptr firstchild;  //孩子链表头指针
}ParNode;
//双亲结点结构
typedef struct{
    parNode node[MAXSIZE];
    int n,r;//用于存放结点数和根节点的位置
}CTree;
```

#### 3.孩子兄弟表示法

```c++
typedef struct TreeNode{
    ElemType data;
    struct TreeNode *fisrtchild,*nextsibling;
}TreeNode,*LinkTree;
```

### II.树和森林与二叉树的转换

#### 1.树化为二叉树

①在兄弟结点之间连线

②对于每个结点，除了其左孩子，去除其余孩子与双亲的连线

![QQ截图20240419212838](C:\Users\Administrator\Desktop\虚动智能\数据结构\pic\QQ截图20240419212838.png)

#### 2.二叉树转化为树

①若p结点为双亲结点的左孩子，则将p结点的所有右子孙都与p结点连接起来

②抹掉原二叉树中双亲与右子孙之间的连线

#### 3.森林转化为二叉树

现将森林中的树转化为二叉树，最后令第一个树作为整个二叉树的根，其余树的根作为新二叉树的根的右子孙。

![QQ截图20240419214050](C:\Users\Administrator\Desktop\虚动智能\数据结构\pic\QQ截图20240419214050.png)

将二叉树转化为森林则进行其逆操作。

### III.树和森林的遍历

树的遍历分为**先序遍历**，**后序遍历**和**层次遍历**。

森林的遍历可将森林分为三个部分：

①第一棵树的根

②第一棵树的所有子树

③除了第一棵树以外其他树组成的森林

以此达到**先序遍历**的操作。

## 四.哈夫曼树(最优树)

### I.基础概念

结点数目相同的二叉树中**完全二叉树**是路径长度最短的二叉树，但**完全二叉树**不一定是哈夫曼树，**哈夫曼树**不唯一。

**权**(weight)：将树中的结点赋予一个有着某种含义的数值，该数值称为此**结点的权**。

结点的**带权路径长度**：从根结点到该结点之间的路径长度与该结点的权的**乘积**。

**树的带权路径长度**：树中所以叶子结点的**带权路径长度之和**。

------

​                                                         **WPL=Σ^n^~i=1~W~i~L~i~**

------

哈夫曼树中权越大的叶子离根越近。

### II.哈夫曼树的构建思路

![QQ截图20240421214547](C:\Users\Administrator\Desktop\虚动智能\数据结构\pic\QQ截图20240421214547.png)

哈夫曼树的结点度数必为0或2。

有n个叶子结点的哈夫曼树共有**2n-1**个结点。

### III.代码实现

#### 1.定义哈夫曼树

```c++
#define MAXSIZE 2*n //n是数值的个数
typedef struct HTNode{
    int weight;
    int parent,lchild,rchild;
}HTNode,*HuffTree;
```

#### 2.初始化

```c++
void InitHufftree(HuffTree HT,int n){
    if(n<=1)return;
    int maxsize=2*n;
    HT=new HTNode[maxsize];
    for(int i=0;i<maxsize;i++){
        HT[i].lchild=0;
        HT[i].rchild=0;
        HT[i].parent=0;
    }
    for(int i=0;i<=n;i++)cin>>HT[i].weight;
}
```

#### 3.构建哈夫曼树

```c++
for(int i=n+1;i<m;i++){
    Select(HT,i-1,s1,s2);//在1到i-1之间找最小的两个值给s1和s2
    HT[s1].parent=i;
    HT[s2].parent=i;
    HT[i].lchild=s1;
    HT[i].rchild=s2;
    HT[i].weight=HT[s1].weight+HT[s2].weight;
}
```

#### IV.哈夫曼编码

将编码按权重组成哈夫曼树，左分支为0，右分支为1。

这样得到的哈夫曼编码是**最优前缀编码**。

##### 代码实现

```c++
void CreatHuffman(HuffTree HT,HuffCode &HC,int n){
    HC=new char*[n+1];
    //为方便i从1开始，这里设置n+1的大小，HC里存放的是n个字符串的首地址
    cd=new char[n]; //cd用于存储哈夫曼编码字符串
    cd[n-1]='\0';
    //前n-2个存储二进制位，最后的n-1存储终止符\0
    for(int i=1,i<=n;i++){
        start=n-1; //初始化start，即cd数组的指针
        c=i; //c用于存储该结点
        f=HT[i].parent; //f为该结点的双亲
        while(f){
            --start; //cd数组的指针移动
            if(HT[f].lchild=c)ch[start]=0;
            else ch[start]=1;
            //判断c结点是双亲的左结点还是右结点
            
            c=f;
            f=HT[f].parent;
            //用于向上回溯
        }
        HC[i]=new char[n-start];
        //提高空间利用率，下一个编码的长度必为n-start;
        strcpy(HC[i],&cd[start]);
        //HC[i]和cd[start]的首地址都是地址，这里将cd的内容赋值给HC[i]这个字符串。 
    }
    delete cd;//释放cd所借去的临时空间
}
```

## 五.并查集

### I.**并查集**的目的

①检测图中是否有环

②实现Kruskal算法(Kruskal算法的Find函数)

③判断无向图的连通性

### II.代码实现

初始化：

```c++
void makeSet(int size){
    for(int i=1;i<=size;i++)parent[i]=i;
}
```

合并：

```c++
void unite(int x,int y){
    int x=find(x);
    int y=find(y);
    if(x==y)return; //若x和y的祖先相等，则无需合并
    parent[x]=y; //若不相等，则使x的双亲结点等于y，代表x代表的链并入了y代表的链
}
```

Find函数：

```c++
int find(int x){
    while(parent[x]==x)return x;  //parent[x]==x表示找到了最顶上的祖先结点
    else find(parent[x]); //若没有找到，则继续递归
}
```

## 六.线段树

### I.基本概念

**线段树**是一种**二叉搜索树**，即对于一条线段，可以用二叉树来表示。

线段树可以用于**快速排序**，**归并排序**等排序算法，理想情况下可将**O(n)**缩短至**O(log n)**。

对于一条线段，其结点的权值取决于该结点**左右子树**的**权值**之和。

由此可得:
$$
tree[i].sum=tree[i*2].sum+tree[i*2+1].sum
$$
定义线段树:

```c++
typedef struct LineNode{
    int weight;
    struct LineNode *left;
    struct LineNode *right;
} LineNode,*LineTree;
```

### II.代码实现

构建线段树：

```c++
inline void build(int i,int l,int r){
    LineNode tree[MVNum];
    tree[i].left=l;
    tree[i].right=r;
    if(l==r)return; //若为叶子结点则返回，作为终止条件
    int mid=(l+r)>>1; //取mid为线段的终点
    build(i*2,l,mid);
    build(i*2+1,mid,r); //通过递归一直构建接下来的分支
    tree[i].weight=tree[i*2].weight+tree[i*2+1].weight; //将双亲结点的权值定为其下子节点的权值之和
}
```

区间查询：

```c++
int Search(int i,int x,int y){
    if(x<=tree[i].left&&tree[i].right<=y)return tree[i].weight;//递归的终止条件，若[l,r]属于结点[i]代表的线段，则返回
    if(y>tree[i].left||tree[i].right<x)return 0; //若某结点与搜寻的线段无交集，则返回0
    int result=0;
    if(x<=tree[i*2].right)result+=Search(i*2,l,r); //若结点的左边界与目标区间有交集，则搜索左子树
    if(y>=tree[i*2+1].left)result+=Search(i*2+1,l,r);
    return result;//最后result返回了所有处于目标区间的数的和
}
```

单点修改：

更改某个点的值，并使包含其的线段权值也随之增加

```c++
void PointChange(int i,int point,int k){
    if(tree[i].left==tree[i].right){
        tree[i].weight+=k;
    	return;
    } //递归终止条件，递归至点则将其权值+k以更改其值
    if(point<=tree[i*2].right)PointChange(i*2,point,k);
    //若点在上一结点左边线段内，则以左结点为起点继续递归
    else PointChange(i*2+1,dis,k);
    //否则则从右结点开始递归
    tree[i].weight=tree[i*2].weight+tree[i*2+1].weight;//更改经过路径中所有线段的权值
    return;
}
```

区间修改：

区间修改可以理解为，给该区间对应线段的结点增加一个标记

```c++
void LineChange(int i,int l,int r,int k){
    if(tree[i].left>=l && tree[i].right<=r){//终止条件，若tree[point]的线段内包含所求线段[l,r]，则令tree[point]的权值+k
        tree[i].weight+=k;
        return;
    }
    int mid=(tree[i].left+tree[i].right)>>1; //若不满足条件，则继续递归
    if(l<=mid)LineChange(i*2,l,r,k); //若所求线段在当前结点的左半边，则对左半边进行递归
    if(r>mid)LineChange(i*2+1,l,r,k);
}
```

单点查询：

```c++
void PointQuery(int i,int x){
    int result;
    result+=tree[i].weight;
    if(tree[i].left==tree[i].right)return;//终止条件，若到达叶子结点(代表线段的点)，则结束循环
    int mid=(tree[i].left+tree[i].right)>>1;
    if(x<=mid)PointQuery(i*2,x); //若所查询的点在当前结点左半边，则对左半边递归
    else PointQuery(i*2+1,x); //否则对右半边递归
}
```



